# 깊이 우선 탐색
# 특정 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로로 탐색

# 탐색 시작 노드를 스택에 삽입하고 방문 처리
# 방문하지 않은 인접 노드가 있다면, 스택에 삽입하고 방문처리
# 방문하지 않은 인접 노드가 없다면, 스택에서 최상단 노드 꺼내기
# 가능할 때까지 반복

def dfs(graph, v, visited):
    visited[v] = True
    print(v, end=' ')
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)

graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

visited = [False] * 9
dfs(graph, 1, visited)


print()
#------------------------------------------------------------------------------------------------------------------------------------------------


# 인접 행렬 방식
# 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식
# 연결되어 있지 않은 노드끼리는 무한의 비용이라고 작성
# 모든 관계 방식을 저장 / 메모리 비효율적 사용
INF = 9999999999
graph = [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]
print(graph)


print()
# 인접 리스트 방식
# 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장
# 파이썬으로 인접리스트를 이용해 그래프를 표현하고자 할때도 단순히 2차원 리스트를 이용하면 된다
# 메모리는 효율적이나, 정보를 얻어오는 속도는 느림
graph = [[] for _ in range(3)]
graph[0].append((1, 7))
graph[0].append((2, 5))
graph[1].append((0, 7))
graph[2].append((0, 5))
print(graph)
